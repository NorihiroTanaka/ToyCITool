# TASK-004: 排他制御 (Concurrency Control / Locking)

## 1. タスク概要
同一リポジトリ・同一ブランチに対するジョブ、あるいはシステム全体でのジョブ実行数を制御し、競合やリソース不足を防ぐ。

## 2. 現状の課題
*   **現状:** Webhookを受信するたびに即座にジョブがトリガーされる可能性がある。
*   **問題点:**
    *   同じディレクトリ（ワークスペース）で複数のビルドが同時に走ると、ファイル操作が競合し、ビルドが失敗する。
    *   CPU/メモリリソースが枯渇する。

## 3. 仕様・要件

### コアコンセプトへの適合
*   **Docker非依存 (No Docker Dependency):**
    *   ファイルシステムのロックやメモリ内キューなど、OS標準機能や言語標準ライブラリを用いて排他制御を行う。
    *   Redisなどの外部KVSや複雑なミドルウェアを必須としない設計とする。
*   **容易な設定 (Easy Configuration):**
    *   同時実行数（Concurrency）はデフォルトで「1（直列実行）」とし、設定なしで最も安全な動作（競合回避）を保証する。
    *   並列数を増やしたい場合のみ `config.yaml` で `max_concurrent_jobs: 2` のように指定するシンプルな形式とする。

### 実装内容
*   **対象ファイル:**
    *   `src/core/job_service.py`: ジョブのキューイングと実行可否判定。
    *   `src/core/workspace_manager.py`: ワークスペースのロック管理。
*   **メカニズム:**
    *   **ワークスペースロック:** 特定のワークスペースパスを使用中の場合、ロックファイル（`.lock`）を作成するか、メモリ上のフラグで管理する。
    *   **同時実行数制限:** システム全体で同時に実行できるジョブ数（ワーカー数）を制限する（例: `max_workers: 2`）。

### 期待される挙動
1.  新しいジョブ要求が来る。
2.  対象のワークスペースが使用中か確認する。
    *   **使用中の場合:** ジョブを「待機中（Pending）」キューに入れる。
3.  実行中のジョブが終了したら、待機中のジョブから次を取り出して実行する。

### 簡易実装案（フェーズ1）
*   `queue.Queue` を使用したジョブキューイングシステムを導入。
*   ワーカースレッドを固定数（例: 1つ）起動し、キューから順次処理することで、擬似的に直列実行を保証する（最も単純な排他制御）。

## 4. 優先度
**Medium**
（個人利用や頻度が低い場合は問題になりにくいが、本格的な運用ではデータの整合性を守るために不可欠）
